#+TITLE: all the stuff learned from the JAVA-DSA-kunal-kushwaha course


* complete git and github kunal kushwaha

** always use the name of the branch if you have multiple branches and you are creating files and pushing stuff and commits to a certain branch
---------------------------------------------------------------------------------------
** upstream is the main repo from which the repo is forked for mods in my own account
---------------------------------------------------------------------------------------
** syncing the forked repo's main with the upstream url repo's main if the forked repo's main branch is a few commits behind the upstream main due to merged commits from the forked repo's other branch

*** git fetch --all --prune
    --all 'here pulls all the branches , commits and other stuff created'
    --prune 'here includes (fetches) the deleted stuff which --all doesn't pull maybe'

*** git reset --hard upstream/main
this resets the origin/main branch of the forked repo with the upstream/main branch of the main repo so as to sync the repo fully
**** then push in the origin/main branch in the local system or 
**** to reduce the 2 commands above you can use
git pull upstream main

*** upstream here pulls from the upstream url and main means from the main branch of the upstream url
**** then you can push the changes to the origin/main branch so as to make the forked repo's main branch in sync with the upstream branch's main

---------------------------------------------------------------------------------------

*** if you want to merge all the commits in one commit without doing a reset and then try git adding all the files aaaaaaand then commiting
**** then use the 'git rebase -i _file_' ( -i means interactive type i.e in nvim vim type and in the underline use the hash of the commit messaeg from the git log )
**** you will get option pick and squash written in the front of the half hash of the file with the file names 
**** pick means taking the commit and squash/s means that it'll merge its commit( i.e the file where it is written as s ) from the bottom till the top until the first pick comes



* #more things to be added#

* stack and heap memory
** for example: a = 10
*** a (reference variable) is stored in stack memory of the above example .
*** heap memory is where 10 (object) is stored of the above example .
*** And a is only pointing to that object in heap memory but 10 is the actual value, pointing to the address of 10 in the memory(in computer)
**** 1. more than 1 reference variables can point to the same object
**** 2. if original object is changed by a reference variable then it will be reflected to all the other variables
*** when an object with no reference variable is found then it is removed from the memory using garbage collection (it happens automatically) all the objects

* intro to java
** how java code executes
*** .java  file has the source code which is in the human readable  format
*** it gets into the compiler and converts the entire file to .class format
*** .class (which is a BYTE CODE) is a file which is a java intermediary language / something else in the java stuff
**** it doesn't run in directly on a system
**** it needs a jvm(Java virtual machine) to run
**** it is the reason why Java is platform independent
***** note jvm is platform dependent we need to execute the .class file again in different platform using the platform dependent jvm
***** this bytecode can run on any machine , the executable is dependent in platform and architecture
***  then the interpreter(line by line) converts it into machine code
**** interpreter compiles the file line by line eg python which is a interpreted language can be excuted line by line

** JDK vs JRE vs JVM vs JIT
*** JDK is java dev kit , it consists of JRE + Dev tools
****  provides package to run and develop java program
**** it is a package that includes
				1. dev tools = to provide an environment to develop your program
				2. JRE = to execute your program
				3. javac = a java compiler
				4. jar = java archiver
				5. javadoc = doc generator
				6. interpreter / loader

*** JRE is java runtime environment, it consists of JVM + library classes
**** It is an installation package that provides environment to only run the program . It consists of :-
				1. Deployment technology
				2. User interface toolkit
				3. Integration libraries
				4. Base libraries
				5. JVM :- Java virtual Machine
*****  After we get the .class file the next thing happen at runtime :
							1. Class loader loads all classes needed to execute the program.
							2. JVM sends code to bytecode verifier to check the format of code.
*** JVM is java virtual machine it consists of JIT just in time compiler

** how the all of the above works JDK, JRE, JVM, JIT
*** at compile time [.java file] --(javac compilation)-----> [.class file]
        1. how jvm works
            -loading: reads .class file and generates binary data of , then object of the class is created in heap
            -linking: i. verifies the .class file | ii. allocates memory for the class variables and default values | iii. replaces symbolic references from the type with direct references (by replacing the variables and other stuff with the values directly)
            -initialization: all static variables are assigned with their values defined in the code and static block. static variables are those variables which do not depend on the object of the classes i.e object independent
                              jvm contains the stack and heap memory allocations , stack memory is created whenever a new program is run
        2. JVM execution
            Interpreter:
            -line by line execution (of the bytecode i.e the .class file)
            -when one method/function(block of code) is called many times it will interpret again and again (which is a limitation)
        3. JIT
            -those methods/functions that are repeated again and again , the jit directly provides the machine code once converted from the main code so that re-interpretation is not required and the code execution becomes a bit faster
*** at runtime : class loader -> byte code verifier -> interpreter -> runtime -> hardware

** how everything points to work like that
*** java source code -> JDK (has the javac compiler converts it into .class file) -> Bytecode -> JVM(converts the bytecode to an executable) -> JRE(then we run that executable in this)
                                                                                                 here^^ somewhere lies the hardware



* structure of a java file
** every file that ends with an extensions .java is a class itself; eg: main.java
** since it's name is main.java(or something before .java) it should contain a class with that name (as in before the extension) in the file itself
** all the code that we'll be writing will be in this class main/name
** remember if a variable name starts with a capital letter then it is a class name (by convention)
** if the class with the name of the file is in the file then that will be a class of the public type , in this case main is the public class type
** public class means that this class will be accessible by all other files , classes, etc
** like cpp , java also has a main function (by convention) from where the program starts , whenever we run the program the compiler will look for main , if it is not present then the compiler will throw error
*** function is a block/collection of code which can be used again and again
** you can run with javac _name_.java and then java _name_ (where name is the class as well as the file name) , also while running the executable with java you can use the name only to run
** explanation of the main.java file

#+begin_src java
 public class main { // inside this block of {} is the int main of java as found in cpp
	public static void main(String[] args) {
		System.out.println("hello world!!");
	}
}
#+end_src

** here class is name group of properties and functions , in the above eg's class we have this function
#+begin_src java
	 public static void main(String[] args) {
		System.out.println("hello world!!");
	}
#+end_src

** all the functions that are in the classes are knows as methods
** also the function name has to be main only #+begin_src public static void main(String[] args) #+end_src  it is reserved to be here if it is not main it will not run
** here public means the same as in the class name part <s public static void main(String[] args) > since main is necessary to run the program so it makes sense to make it available to be executed from anywhere i.e public class type , if we make it private then it will not be available like the public class and hence it will not be valid
*** main function is the entry point of the function
*** here static means:this main function/method is a part of the -Main- class also main is required to be run without creating an object of this Main class ,so we use the static type . Since nothing is running before the main() function then there is no use of making an object there
*** so static variables and functions are the variables and functions that don't depend on the object
*** void is the return type of the function, since we don't want any value here so we have used void(like in cpp)
*** (String[] args) are the arguments , collection of strings
*** here args is the arguments given in the terminal with java command (like java Main 50 100 ...) after compiling with the javac(like javac Main(class/file name)) and the no inside the [] is the index of the array to which the values given with the java command will be printed , the values given with the java command is stored in the String[] array
*** javac -d _directory_ _name_: this -d flag is used to give a directory to store the .class file
*** package is the folder where the java file will lie, eg package com.kunal , this com.kunal is a subfolder in the com folder (you can make more of those subfolders) , '.' period means subfolder
