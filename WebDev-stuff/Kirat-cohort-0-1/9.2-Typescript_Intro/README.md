# Typescript (still the devs' nightmare)

## Types of languages

- Strongly typed vs loosely typed
The terms strongly typed and loosely typed refer to how programming languages handle types, particularly how strict they are about type conversions and type safety.

| Strongly typed languages | Loosely typed languages |
| ------- | ------- |
| Examples - Java, C++, C, Rust | Examples - Python, Javascript, Perl, php |
| Benefits - | Benefits - |
| Lesser runtime errors | Easy to write code |
| Stricter codebase | Fast to bootstrap |
| Easy to catch errors at compile time | Low learning curve |

- Code doesn‚Äôt work ‚ùå

```cpp
#include <iostream>

int main() {
int number = 10;
number = "text";
return 0;
}
```

- Code does work ‚úÖ

```js
function main() {
let number = 10;
number = "text";
return number;
}
```

> People realised that javascript is a very power language, but lacks types. Typescript was introduced as a new language to add types on top of javascript.

## What is Typescript

- What is typescript?
  - TypeScript is a programming language developed and maintained by Microsoft.
  - It is a strict syntactical superset of JavaScript and adds optional static typing to the language.
  - It is backwards compatible with JS

- Where/How does typescript code run?
  - Typescript code never runs in your browser. Your browser can only understand javascript.
  - Javascript is the runtime language (the thing that actually runs in your browser/nodejs runtime)
  - Typescript is something that compiles down to javascript, more appropriately 'transpiled' down to JS
  - When typescript is compiled down to javascript, you get type checking (similar to C++). If there is an error, the conversion to Javascript fails.

- Typescript compiler
  - `tsc` is the official typescript compiler that you can use to convert Typescript code into Javascript
  - There are many other famous compilers/transpilers for converting Typescript to Javascript. Some famous ones are -
    - `esbuild`
    - `swc`

## Creating a typescript node project

 The tsc compiler
We can bootstrap a simple Typescript Node.js application locally on our machines by the following steps:

- Step 1 - Install tsc/typescript globally
` npm install -g typescript `
- Step 2 - Initialize an empty Node.js project with typescript

```bash
mkdir node-app
cd node-app
npm init -y
npx tsc --init
```

These commands should initialize two files in your project

- Step 3 - Create a a.ts file
` npm install -g typescript `

```ts
const x: number = 1;
console.log(x);
```

- Step 4 - Compile the ts file to js file
` tsc -b `
- Step 5 - Explore the newly generated index.js file
Notice how there is no typescript code in the javascript file. It‚Äôs a plain old js file with no types
- Step 6 - Try assigning x to a string
Make sure you convert the const to let

```ts
let x: number = 1;
x = "harkirat"
console.log(x);
```

- Step 7 - Delete a.js
- Step 8 - Try compiling the code again
` tsc -b `
Notice all the errors you see in the console. This tells you there are type errors in your codebase.
Also notice that no index.js is created anymore
notion image
This is the high level benefit of typescript. It lets you catch type errors at compile time

- About the tsconfig.json
  - This file contains a bunch of variables we can call them configurations, which we can turn true or false and based on that the compilation process will change.
  - There are a lot of configurations within the file which we don't need to learn all of them, but some popular ones should be learned
- About package.json
  - It has nothing to do with typescript
  - It just contains the packages, their versions and some other stuff regarding the package management

- rule of thumb: You don't need to look the generated js file from the TS compiler tsc, since we are writing a very few lines of code so it is readable but once we write very complex stuff, it gets super ugly because it is generated by the compiler, just like the index.html generated when we build the react project files using vite.

## Basic Types in TypeScript

- Typescript provides us with some basic types such as `number`, `string`, `boolean`, `null`, `undefined`.
Let‚Äôs create some simple applications using these types -

- Problem 1 - Hello world

  > üí° Thing to learn - How to give types to arguments of a function

  - Write a function that greets a user given their first name.
    Argument - firstName
    Logs - Hello {firstName}
    Doesn‚Äôt return anything
  Solution: Here we can see that everything is the same as JS, but the thing that is different is the argument which requires a type since it is TS and it has types for most of the things so as to reduce errors

```js
function greet(name: string) {
 console.log('heloooo', name);
}
greet('byeeeeeeeee');
```

- Here the function can get as many arguments so each of them will have to defined a type like we have done above

- Problem 2 - Sum function

  > üí° Thing to learn - How to assign a return type to a function

  - Write a function that calculates the sum of two functions
  Solution: The following is the solution of the above question and we can explicitly define the types there in the argument itself with a colon and then we can also specify the type of the return statement after the argument brackets like done in the following.
  - But if we don't define the type of the function explicitly still typescript is able to know the type automatically. This is known as "type inference" since the two numbers that were defined with the type inside the function were already numbers and as such if we add the two we'll still get a number and so TS automatically knows that, but we should know that typescript doesn't know the logic it only knows the type. It is a good practice to set the type of the function.

  ```ts
  function Sum(a: number, b: number): number {
    return a + b;
  }

  console.log(Sum(1, 2));
  ```

- Problem 3 - Return true or false based on if a user is 18+
solution:

```ts
function isLegal(a: number): boolean {
 if (a >= 18) {
  return true;
 } else {
  return false;
 }
}

console.log(isLegal(20));
console.log(isLegal(10));
```

> üí° Thing to learn - Type inference

- Problem 4 - Create a function that takes another function as input, and runs it after 1 second.
solution: Here we will use the callback function type definition which can be done by the following way.
Firstly the main `Callback` function receives a function as an argument and as such we'll have to define the function type in this manner  `fn: () => void` where the first is the name followed by colon which is the way to show types followed by another `()` which shows the function and followed by the `=>` and then the type that will be returned which is void in our case since the callback doesn't expect/return any value or doesn't has any argument and so it returns nothing i.e `void`

```ts
function Callback(fn: () => void) {
 setTimeout(fn, 1000);
}

Callback(function () {
 console.log('ran after 1 second');
});

```

## The tsconfig file

Now we'll need to understand the tsconfig.json configuration file and some of the options that are present in the file and what happens to the compilation process when we flip their arguments.

The tsconfig file has a bunch of options that we can change to change the compilation process.
Some of these include

1. **`target`**

- The `target` option in a tsconfig.json file specifies the "ECMAScript" target version to which the "TypeScript" compiler will compile the "TypeScript" code.
- The version specifies the type of things that were introduced in the new version and if the browser or the runtime doesn't support the code will be of no use. We can set it to any version as per our choice but the default one will be the most recent/newest one
- To try it out, try compiling the following code for target being ES5 and es2020

```ts
const greet = (name: string) => `Hello, ${name}!`;
```

Output for ES2016(understands arrow functions)

```js
const greetings = (name) => `Hello, ${name}!`;
```

Output for ES5(doesn't undestand arrow function)

```js
var greetings = function (name) { return "Hello, ".concat(name, "!"); };
```

Output for ES2020

```js
const greetings = (name) => `Hello, ${name}!`;
```

- The best use case for this is the backwards compatibility where we can compile the TS code with latest standards and the compile it down to the oldest standards as old as the IE days where it supports only a very old version of ECMAscript.

2. **`rootDir`** and **`outDir`**

- Where should the compiler look for .ts files. Good practise is for this to be the `src` folder
  - So we should create a `src` folder which will have all the source files
- And where should the compiler look for spit out the .js files. We'll create folder called `dist`/`build` which will have all the compiled down output js files. We can name it anything we want but this is commonly used.

4. noImplicitAny

- This is by default set to true in the tsconfig file and if we set it to false, then it'll be less strict and will stop checking explicitly for types and will accept implicitly the type. Eg: In cases where we are migrating from JS to TS and we don't want to infer types since there will be a thousand functions and it'll take a hell lot of time and will be done slowly but there is a need to compile the code atleast
- Try enabling it and see the compilation errors on the following code

```js
const greet = (name) => `Hello, ${name}!`;
```

Then try disabling it
5. removeComments
Weather or not to include comments in the final js file. We can just set it to true since there is no use of using comments in the final js file because the whole time will be spent on the main TS file

There are a thousands of these configurations in tsconfig for typescript and we don't need to know everything and as time goes by we can learn on the go.
